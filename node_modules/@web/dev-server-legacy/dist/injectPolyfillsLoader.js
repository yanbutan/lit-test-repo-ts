"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectPolyfillsLoader = void 0;
const dom5_1 = require("@web/dev-server-core/dist/dom5");
const parse5_1 = require("parse5");
const polyfills_loader_1 = require("polyfills-loader");
const constants_1 = require("./constants");
const findJsScripts_1 = require("./findJsScripts");
function findScripts(indexUrl, documentAst) {
    const scriptNodes = findJsScripts_1.findJsScripts(documentAst);
    const files = [];
    const inlineScripts = [];
    const inlineScriptNodes = [];
    scriptNodes.forEach((scriptNode, i) => {
        const type = polyfills_loader_1.getScriptFileType(scriptNode);
        let src = dom5_1.getAttribute(scriptNode, 'src');
        if (!src) {
            const suffix = type === 'module' ? `&${constants_1.PARAM_TRANSFORM_SYSTEMJS}=true` : '';
            src = `inline-script-${i}.js?source=${encodeURIComponent(indexUrl)}${suffix}`;
            inlineScripts.push({
                path: src,
                type,
                content: dom5_1.getTextContent(scriptNode),
            });
            inlineScriptNodes.push(scriptNode);
        }
        else if (type === 'module') {
            const separator = src.includes('?') ? '&' : '?';
            src = `${src}${separator}${constants_1.PARAM_TRANSFORM_SYSTEMJS}=true`;
        }
        files.push({
            type,
            path: src,
        });
    });
    return { files, inlineScripts, scriptNodes, inlineScriptNodes };
}
/**
 * transforms index.html, extracting any modules and import maps and adds them back
 * with the appropriate polyfills, shims and a script loader so that they can be loaded
 * at the right time
 */
async function injectPolyfillsLoader(context, polyfills) {
    const documentAst = parse5_1.parse(context.body);
    const { files, inlineScripts, scriptNodes } = findScripts(context.url, documentAst);
    const polyfillsLoaderConfig = {
        modern: {
            files: files.map(f => (Object.assign(Object.assign({}, f), { type: f.type === polyfills_loader_1.fileTypes.MODULE ? polyfills_loader_1.fileTypes.SYSTEMJS : f.type }))),
        },
        polyfills: polyfills === false
            ? { regeneratorRuntime: 'always' }
            : Object.assign({ coreJs: true, regeneratorRuntime: 'always', fetch: true, abortController: true, webcomponents: true }, (polyfills === true ? {} : polyfills)),
        preload: false,
    };
    // we will inject a loader, so we need to remove the inline script nodes as the loader
    // will include them as virtual modules
    for (const scriptNode of scriptNodes) {
        // remove script from document
        dom5_1.remove(scriptNode);
    }
    const result = polyfills_loader_1.injectPolyfillsLoader(parse5_1.serialize(documentAst), polyfillsLoaderConfig);
    return {
        htmlPath: context.url,
        indexHTML: result.htmlString,
        inlineScripts,
        polyfills: result.polyfillFiles,
    };
}
exports.injectPolyfillsLoader = injectPolyfillsLoader;
//# sourceMappingURL=injectPolyfillsLoader.js.map